# 03-1 기본 연산자



### 항과 연산자

- 단항 연산자
  - `++num`
- 이항 연산자
  - `num1 + num2`

- 삼항 연산자
  - `(5 > 3) ? 1 : 0`

- 연산자의 우선순위는 단항연산자가 가장 높고, 이항, 삼항연산자 순이다.



### 대입연산자

- 이항 연산자 중 순위가 가장 낮음



### 부호연산자

- +, - 두 가지가 있다. 더하기, 빼기에 사용되는 이항 연산자인 동시에 부호를 의미하는 단항 연산다로도 사용된다.



### 산술 연산자

- `/` : 몫을 구하는 연산자이다.

- 나머지를 구하는 `%`연산자의 순위는 `*`, `/` 연산자의 순위와 동일하다.



### 증가 & 감소 연산자

- `++`, `--` 로 이루어진 단행 연산자이며, 연산자 앞이나 뒤에 사용하여 값을 1만큼 늘리거나 줄임

- 피연산자의 앞에 쓰이냐 혹은 뒤에 쓰이냐에 따라 결과 값이 달라질 수 있다.

```java
val = ++num;		//먼저 num 값이 1 증가한 후 val 변수에 대입
val = num++;		//val 변수에 기존 num 값을 대입한 후 num값이 1 증가
    
int value = 10;
int num = ++value;	//num에 11이 대입

int value = 10;
int num = value++;	//num에 10이 대입 (대입된 후 value값이 증가하므로)
```



### 관계 연산자

- 비교 연산자라고도 부른다.



### 논리 연산자

- 주로 관계 연산자와 함께 사용한다.
- 관계 연산자의 우선순위가 논리 연산자보다 높으므로, 관계 연산자의 결과 값을 기반으로 논리 연산자의 결과 값을 계산한다.
- `&&(논리 곱)`, `||(논리 합)`, `!(부정)` 

```java
boolean val = (5<3) && (5>2)	//False
boolean val = (5<3) || (5>2)	//True
```



### 단락 회로 평가

- 논리 곱 연산과 합 연산을 할 때, 두 항을 모두 실행하지 않아도 결과값을 알 수 있음
- 이 때, 나머지 항은 실행되지 않는 것을 단락 회로 평가(Short Circuit Evaluation; SCE) 라고 한다.



### 복합 대입 연산자

- 대입 연산자와 다른 연산자를 조합하여 하나의 연산자처럼 사용하는 연산자이다.
- **산술 연산자**와 **비트 연산자**와 함께 사용된다.
- 변수를 반복적으로 사용하지 않아도 된다는 장점이 있음



### 조건 연산자

- 연산에 필요한 항의 수가 3개여서 삼항 연산자라고 한다.

|         연산자          |                       기능                       |           연산 예           |
| :---------------------: | :----------------------------------------------: | :-------------------------: |
| 조건식 ? 결과 1: 결과2; | 조건식이 참이면 결과 1을, 거짓이면 결과 2를 선택 | int num = (5 > 3) ? 10: 20; |

 

위 의 연산 예에서 조건식 `(5 > 3) ` 은 참이므로, 앞의 10이 변수 num에 대입된다.





# 03-2 비트연산자



### 비트 논리 연산자

#### 1. &(and) 연산자

- &연산자는 두 개의 비트 값이 모두 1인 경우에만 연산의 결과 값이 1이 된다.

```java
//비트 연산 예시
int num1 = 5;
int num2 = 10;
int result = num1 & num2;	//결과 값은 0


	num1 : 0 0 0 0 0 1 0 1
  & num2 : 0 0 0 0 1 0 1 0
  -------------------------
  result : 0 0 0 0 0 0 0 0 
```



#### 2. |(or) 연산자

- 비트 값이 하나라도 1이면 연산 결과 값이 1이 된다.

```java
//비트 연산 예시
int num1 = 5;
int num2 = 10;
int result = num1 & num2;	//결과 값은 15


	num1 : 0 0 0 0 0 1 0 1
  & num2 : 0 0 0 0 1 0 1 0
  -------------------------
  result : 0 0 0 0 1 1 1 1 
```





#### 3. ^(XOR) 연산자

- 비트 값이 서로 같은 값이면 0, 다른 값이면 1의 결과 값을 갖는다.



#### 4. ~ 연산자

- 반전 연산자는 비트 값을 0은 1로, 1은 0으로 바꾸는 연산자이다.

```java
//비트 연산 예시
int num2 = 10;
int result = ~num2;	//결과 값은 -11


	num1 : 0 0 0 0 1 0 1 0
  -------------------------
  & num2 : 1 1 1 1 0 1 0 1
```

- num2는 음수이므로, 이를 양수로 변환하면(마지막 자리에서 1을 빼주고, 그 값에 대한 1의 보수를 구한다.) 11이다. 따라서 결과값은 `-11` 이 된다.





### 비트 이동 연산자

- 시프트 연산자라고도 한다. 



#### 1. << 연산자

- 왼쪽으로 비트를 이동시킨다.
- 왼쪽으로 n비트 이동한다는 것은 기존의 값에 2^n 만큼 곱한다는 의미이다.

```java
int num = 5;
num << 2;	// 결과 값은 20


num		 : 0 0 0 0 0 1 0 1
num << 2 : 0 0 0 1 0 1 0 0	// 두 비트만큼 왼쪽으로 이동
```



#### 2. >> 연산자

- 오른쪽으로 비트를 이동시킨다.
- 기존의 값에 2^n 만큼 나눈다는 의미이다. (몫)
- 왼쪽에 채워지는 비트 값은 기존 값의 부호 비트와 동일하다.

```java
int num = 10;
num >> 2;	// 결과 값은 2


num		 : 0 0 0 0 1 0 1 0
num >> 2 : 0 0 0 0 0 0 1 0	// 두 비트만큼 오른쪽으로 이동
```



#### 3. >>> 연산자

- `>>` 연산과 동일하게 비트를 오른쪽으로 이동시키나, 왼쪽에 채워지는 비트 값이 부호의 비트와 상관 없이 무조건 0이 된다.



### 연산자 우선순위

- 단항 연산자가 가장 높고, 이항, 삼항 순이다.

- 대입 연산자의 우선순위가 가장 낮다.

- 산술, 관계, 논리, 대입 연산자 순서로 우선순위를 가지며 () 의 우선순위가 가장 높다.



